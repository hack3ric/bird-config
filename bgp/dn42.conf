roa4 table dn42_roa_v4;
roa6 table dn42_roa_v6;

protocol static {
  roa4 { table dn42_roa_v4; };
  include "../dn42_roa_v4.conf";
};

protocol static {
  roa6 { table dn42_roa_v6; };
  include "../dn42_roa_v6.conf";
};


# (64511, 1) :: latency \in (0, 2.7ms]
# (64511, 2) :: latency \in (2.7ms, 7.3ms]
# (64511, 3) :: latency \in (7.3ms, 20ms]
# (64511, 4) :: latency \in (20ms, 55ms]
# (64511, 5) :: latency \in (55ms, 148ms]
# (64511, 6) :: latency \in (148ms, 403ms]
# (64511, 7) :: latency \in (403ms, 1097ms]
# (64511, 8) :: latency \in (1097ms, 2981ms]
# (64511, 9) :: latency > 2981ms
# (64511, x) :: latency \in [exp(x-1), exp(x)] ms (for x < 10)
function dn42_update_latency(int link_latency) {
  bgp_community.add((64511, link_latency));
       if (64511, 9) ~ bgp_community then { bgp_community.delete([(64511, 1..8)]); return 9; }
  else if (64511, 8) ~ bgp_community then { bgp_community.delete([(64511, 1..7)]); return 8; }
  else if (64511, 7) ~ bgp_community then { bgp_community.delete([(64511, 1..6)]); return 7; }
  else if (64511, 6) ~ bgp_community then { bgp_community.delete([(64511, 1..5)]); return 6; }
  else if (64511, 5) ~ bgp_community then { bgp_community.delete([(64511, 1..4)]); return 5; }
  else if (64511, 4) ~ bgp_community then { bgp_community.delete([(64511, 1..3)]); return 4; }
  else if (64511, 3) ~ bgp_community then { bgp_community.delete([(64511, 1..2)]); return 3; }
  else if (64511, 2) ~ bgp_community then { bgp_community.delete([(64511, 1..1)]); return 2; }
  else return 1;
}


# (64511, 21) :: bw >= 0.1mbit
# (64511, 22) :: bw >= 1mbit
# (64511, 23) :: bw >= 10mbit
# (64511, 24) :: bw >= 100mbit
# (64511, 25) :: bw >= 1000mbit
# (64511, 2x) :: bw >= 10^(x-2) mbit
# bw = min(up,down) for asymmetric connections
function dn42_update_bandwidth(int link_bandwidth) {
  bgp_community.add((64511, link_bandwidth));
       if (64511, 21) ~ bgp_community then { bgp_community.delete([(64511, 22..29)]); return 21; }
  else if (64511, 22) ~ bgp_community then { bgp_community.delete([(64511, 23..29)]); return 22; }
  else if (64511, 23) ~ bgp_community then { bgp_community.delete([(64511, 24..29)]); return 23; }
  else if (64511, 24) ~ bgp_community then { bgp_community.delete([(64511, 25..29)]); return 24; }
  else if (64511, 25) ~ bgp_community then { bgp_community.delete([(64511, 26..29)]); return 25; }
  else if (64511, 26) ~ bgp_community then { bgp_community.delete([(64511, 27..29)]); return 26; }
  else if (64511, 27) ~ bgp_community then { bgp_community.delete([(64511, 28..29)]); return 27; }
  else if (64511, 28) ~ bgp_community then { bgp_community.delete([(64511, 29..29)]); return 28; }
  else return 29;
}

# (64511, 31) :: not encrypted
# (64511, 32) :: encrypted with unsafe vpn solution
# (64511, 33) :: encrypted with safe vpn solution (but no PFS - the usual OpenVPN p2p configuration falls in this category)
# (64511, 34) :: encrypted with safe vpn solution with PFS (Perfect Forward Secrecy)
function dn42_update_crypto(int link_crypto) {
  bgp_community.add((64511, link_crypto));
       if (64511, 31) ~ bgp_community then { bgp_community.delete([(64511, 32..34)]); return 31; }
  else if (64511, 32) ~ bgp_community then { bgp_community.delete([(64511, 33..34)]); return 32; }
  else if (64511, 33) ~ bgp_community then { bgp_community.delete([(64511, 34..34)]); return 33; }
  else return 34;
}

function dn42_update_flags(int link_latency; int link_bandwidth; int link_crypto) {
  dn42_update_latency(link_latency);
  dn42_update_bandwidth(link_bandwidth);
  dn42_update_crypto(link_crypto);
}

function dn42_import_check() {
  if is_valid_network_42() && !is_self_net() then {
    if (net.type = NET_IP4 && roa_check(dn42_roa_v4, net, bgp_path.last) != ROA_VALID)
      || (net.type = NET_IP6 && roa_check(dn42_roa_v6, net, bgp_path.last) != ROA_VALID) then
    {
      print "[dn42] ROA check failed for ", net, " ASN ", bgp_path.last;
      reject;
    }
  } else reject;
}

function dn42_export_check() {
  if !is_valid_network_42() || source !~ [RTS_STATIC, RTS_BGP] then reject;
}

function dn42_import_prepend(int prepend_count) {
  bgp_prepend(prepend_count, bgp_path.first);
}

function dn42_export_prepend(int prepend_count) {
  bgp_prepend(prepend_count, OWNAS42);
}

function dn42_bgp_import(int prepend_count; int link_latency; int link_bandwidth; int link_crypto) {
  dn42_import_check();
  dn42_import_prepend(prepend_count);
  dn42_update_flags(link_latency, link_bandwidth, link_crypto);
  accept;
}

function dn42_bgp_export(int prepend_count; int link_latency; int link_bandwidth; int link_crypto) {
  dn42_export_check();
  dn42_export_prepend(prepend_count);
  dn42_update_flags(link_latency, link_bandwidth, link_crypto);
  bgp_med = 0;
  bgp_med = bgp_med + ( ( 4 - ( link_crypto - 30 ) ) * 600 );
  bgp_med = bgp_med + ( ( 9 - ( link_bandwidth - 20 ) ) * 100);
  bgp_med = bgp_med + ( ( link_latency - 1) * 300);
  accept;
}

template bgp dn42_peer from bgp_rate_limited {
  local as OWNAS42;
  path metric 1;

  ipv4 {
    import where dn42_bgp_import(0, 1, 24, 33);
    export where dn42_bgp_export(0, 1, 24, 33);
    import table;
  };

  ipv6 {
    import where dn42_bgp_import(0, 1, 24, 33);
    export where dn42_bgp_export(0, 1, 24, 33);
    import table;
  };
}

template bgp dn42_peer_extended from dn42_peer {
  ipv4 {
    extended next hop;
  };
}
